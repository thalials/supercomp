{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2022/1. Professores : Andr\u00e9 Filipe M. Batista Luciano Silva Hor\u00e1rio das aulas : Turma A - Prof. Andr\u00e9 Filipe: Ter\u00e7a - 9h45, Sexta - 07h30 Turma B - Prof. Luciano Silva: Quarta - 13h30, Sexta - 13h30 Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2022/1. Professores : Andr\u00e9 Filipe M. Batista Luciano Silva Hor\u00e1rio das aulas : Turma A - Prof. Andr\u00e9 Filipe: Ter\u00e7a - 9h45, Sexta - 07h30 Turma B - Prof. Luciano Silva: Quarta - 13h30, Sexta - 13h30","title":"SuperComputa\u00e7\u00e3o"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Hor\u00e1rios: Turma A - Prof. Andr\u00e9 Filipe: Ter\u00e7a - 9h45, Sexta - 07h30 Turma B - Prof. Luciano Silva: Quarta - 13h30, Sexta - 13h30 Plano de aulas - Turma A Data Quest\u00e3o/Problema Conte\u00fado/Atividade 15/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 18/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 22/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 25/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 04/03/22 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 08/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 11/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 15/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 22/03/22 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 25/03/22 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 29/03/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 05/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 08/04/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 12/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 19/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 26/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 29/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 03/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 06/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 10/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 13/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 17/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 20/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 24/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 27/05/22 Quiz para a PF Quiz para a PF 31/05/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 07/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/06/22 Prova Final Prova Final 14/06/22 Prova Final Prova Final Plano de aulas - Turma B Data Quest\u00e3o/Problema Conte\u00fado/Atividade 16/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 18/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 23/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 25/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 04/03/22 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 09/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 11/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 23/03/22 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 25/03/22 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 30/03/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 06/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 08/04/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 13/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 20/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 27/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Contru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 29/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 04/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 06/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 13/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 18/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 20/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 25/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 27/05/22 Quiz para a PF Quiz para a PF 01/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 08/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/06/22 Prova Final Prova Final 15/06/22 Prova Final Prova Final","title":"Burocracias"},{"location":"sobre/#burocracias","text":"Hor\u00e1rios: Turma A - Prof. Andr\u00e9 Filipe: Ter\u00e7a - 9h45, Sexta - 07h30 Turma B - Prof. Luciano Silva: Quarta - 13h30, Sexta - 13h30 Plano de aulas - Turma A Data Quest\u00e3o/Problema Conte\u00fado/Atividade 15/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 18/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 22/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 25/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 04/03/22 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 08/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 11/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 15/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 22/03/22 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 25/03/22 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 29/03/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 05/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 08/04/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 12/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 19/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 26/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 29/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 03/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 06/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 10/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 13/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 17/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 20/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 24/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 27/05/22 Quiz para a PF Quiz para a PF 31/05/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 07/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/06/22 Prova Final Prova Final 14/06/22 Prova Final Prova Final Plano de aulas - Turma B Data Quest\u00e3o/Problema Conte\u00fado/Atividade 16/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 18/02/22 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 23/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 25/02/22 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 04/03/22 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 09/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 11/03/22 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/03/22 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 23/03/22 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 25/03/22 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 30/03/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 06/04/22 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 08/04/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 13/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 20/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 27/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Contru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 29/04/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 04/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 06/05/22 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 13/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 18/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 20/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 25/05/22 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 27/05/22 Quiz para a PF Quiz para a PF 01/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 08/06/22 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/06/22 Prova Final Prova Final 15/06/22 Prova Final Prova Final","title":"Burocracias"},{"location":"aulas/01-introducao/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o \u00b6 Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo. Problemas estudados em SuperComputa\u00e7\u00e3o \u00b6 Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos. Ferramental \u00b6 Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. # TODO: exerc\u00edcio aqui Algoritmos sequenciais \u00b6 Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib # TODO: exerc\u00edcio aqui Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. #TODO: seu c\u00f3digo aqui Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos. Algoritmos paralelos \u00b6 Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"01 - Introdu\u00e7\u00e3o"},{"location":"aulas/01-introducao/#01-introducao-a-supercomputacao","text":"Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo.","title":"01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#problemas-estudados-em-supercomputacao","text":"Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos.","title":"Problemas estudados em SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#ferramental","text":"Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. # TODO: exerc\u00edcio aqui","title":"Ferramental"},{"location":"aulas/01-introducao/#algoritmos-sequenciais","text":"Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib # TODO: exerc\u00edcio aqui Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. #TODO: seu c\u00f3digo aqui Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos.","title":"Algoritmos sequenciais"},{"location":"aulas/01-introducao/#algoritmos-paralelos","text":"Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"Algoritmos paralelos"},{"location":"aulas/02-03-implementacao-c%2B%2B/","text":"02/03 - Implementa\u00e7\u00e3o em C++ \u00b6 A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Compila\u00e7\u00e3o \u00b6 Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel Entrada e sa\u00edda em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s) Vetores em C++ com Vector \u00b6 A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Matrizes (vers\u00e3o 1) \u00b6 Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? Refer\u00eancias e passagem de dados \u00b6 Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & . Uma primeira otimiza\u00e7\u00e3o \u00b6 Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"02 e 03 - C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#0203-implementacao-em-c","text":"A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre.","title":"02/03 - Implementa\u00e7\u00e3o em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#compilacao","text":"Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel","title":"Compila\u00e7\u00e3o"},{"location":"aulas/02-03-implementacao-c%2B%2B/#entrada-e-saida-em-c","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"Entrada e sa\u00edda em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#vetores-em-c-com-vector","text":"A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia.","title":"Vetores em C++ com Vector"},{"location":"aulas/02-03-implementacao-c%2B%2B/#matrizes-versao-1","text":"Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o?","title":"Matrizes (vers\u00e3o 1)"},{"location":"aulas/02-03-implementacao-c%2B%2B/#referencias-e-passagem-de-dados","text":"Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & .","title":"Refer\u00eancias e passagem de dados"},{"location":"aulas/02-03-implementacao-c%2B%2B/#uma-primeira-otimizacao","text":"Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"Uma primeira otimiza\u00e7\u00e3o"},{"location":"aulas/04-profiling/","text":"04 - Medi\u00e7\u00e3o de desempenho \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind Warm-up: O problema da soma de uma matriz \u00b6 O c\u00f3digo abaixo apresenta duas formas de realizar a soma de todos os elementos de uma matriz. Compile o c\u00f3digo e execute. Voc\u00ea sabe dizer qual a diferen\u00e7a de naive_sum e improved_sum ? #include <iostream> #include <algorithm> using namespace std ; constexpr int M = 2048 ; constexpr int N = 2048 ; double naive_sum ( const double a [][ N ]){ double sum = 0.0 ; for ( int j = 0 ; j < N ; ++ j ) { for ( int i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; } return sum ; } double improved_sum ( const double a [][ N ]) { double sum = 0.0 ; for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } int main () { static double a [ M ][ N ]; fill_n ( & a [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << naive_sum ( a ) << endl ; static double b [ M ][ N ]; fill_n ( & b [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << improved_sum ( b ) << endl ; return 0 ; } Vamos usar o Valgrind para verificar se h\u00e1 diferen\u00e7as entre naive_sum e improved_sum . Supondo que o seu arquivo se chama sum.cpp execute: g++ -Wall -O3 -g sum.cpp -o sum E execute ent\u00e3o programa via valgrind : valgrind --tool=callgrind ./sum O valgrind ir\u00e1 retornar algo como: ==3079146== Callgrind, a call-graph generating cache profiler ==3079146== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al. ==3079146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==3079146== Command: ./sum ==3079146== ==3079146== For interactive control, run 'callgrind_control -h'. 1 1 ==3079146== ==3079146== Events : Ir ==3079146== Collected : 50553796 ==3079146== ==3079146== I refs: 50,553,796 Onde 3079146 \u00e9 o PID da execu\u00e7\u00e3o. Na sua m\u00e1quina ser\u00e1 um outro valor. Ele tamb\u00e9m gerou um arquivo callgrind.out.{PID} . Execute a ferramenta callgrind_annotate para verificar o resultado do profiling. callgrind_annotate callgrind.out.3079146 sum.cpp E seu output ser\u00e1 como segue: -------------------------------------------------------------------------------- Profile data file 'callgrind.out.3079146' (creator: callgrind-3.15.0) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 10863316 Trigger: Program termination Profiled target: ./sum (PID 3079146, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: sum.cpp Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 50,553,796 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 31,479,818 sum.cpp:main [/home/user/andre/profile/sum] 16,777,221 /usr/include/c++/9/bits/stl_algobase.h:main 948,840 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 554,233 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 273,488 /build/glibc-eX1tMB/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object 117,179 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so] -------------------------------------------------------------------------------- -- User-annotated source: sum.cpp -------------------------------------------------------------------------------- Ir . #include<iostream> . #include<algorithm> . using namespace std; . . constexpr int M = 2048; . constexpr int N = 2048; . . double naive_sum(const double a[][N]){ 1 double sum = 0.0; 6,144 for(int j = 0; j < N; ++j) { 12,587,008 for(int i = 0; i < M; ++i) 4,194,304 sum += a[i][j]; . } . return sum; . } . . double improved_sum(const double a[][N]) { 4,097 double sum = 0.0; 8,192 for(int i = 0; i < M; ++i) 4,194,304 for(int j = 0; j < N; ++j) 10,485,760 sum +=a[i][j]; . return sum; . } . 5 int main() { . static double a[M][N]; . fill_n(&a[0][0], M*N, 1.0 / (M*N)); . cout << naive_sum(a) << endl; . static double b[M][N]; . fill_n(&b[0][0], M*N, 1.0 / (M*N)); . cout << improved_sum(b) << endl; . return 0; 6 } -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 31,479,821 events annotated O que voc\u00ea pode dizer sobre o desempenho do programa? Por que h\u00e1 diferen\u00e7a de instruction fetch (IR) entre naive_sum e improved_sum ? Tip Dica: Verifique a discuss\u00e3o no StackOverflow sobre isso. Neste link https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra Dist\u00e2ncia: Euclides ing\u00eanuo \u00b6 Compile o c\u00f3digo-fonte da implementa\u00e7\u00e3o ing\u00eanua que fizemos na aula passada, com profiling habilitado para medir os tempos de execu\u00e7\u00e3o. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, execute o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) O que tomou mais tempo de execu\u00e7\u00e3o da vers\u00e3o ing\u00eanua? Medindo os tempos no seu pr\u00f3prio programa \u00b6 Voc\u00ea vai perceber, ao executar a atividade anterior, que boa parte do tempo \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST Matrizes (vers\u00e3o 2) \u00b6 Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"04 - Profiling"},{"location":"aulas/04-profiling/#04-medicao-de-desempenho","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/04-profiling/#warm-up-o-problema-da-soma-de-uma-matriz","text":"O c\u00f3digo abaixo apresenta duas formas de realizar a soma de todos os elementos de uma matriz. Compile o c\u00f3digo e execute. Voc\u00ea sabe dizer qual a diferen\u00e7a de naive_sum e improved_sum ? #include <iostream> #include <algorithm> using namespace std ; constexpr int M = 2048 ; constexpr int N = 2048 ; double naive_sum ( const double a [][ N ]){ double sum = 0.0 ; for ( int j = 0 ; j < N ; ++ j ) { for ( int i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; } return sum ; } double improved_sum ( const double a [][ N ]) { double sum = 0.0 ; for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } int main () { static double a [ M ][ N ]; fill_n ( & a [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << naive_sum ( a ) << endl ; static double b [ M ][ N ]; fill_n ( & b [ 0 ][ 0 ], M * N , 1.0 / ( M * N )); cout << improved_sum ( b ) << endl ; return 0 ; } Vamos usar o Valgrind para verificar se h\u00e1 diferen\u00e7as entre naive_sum e improved_sum . Supondo que o seu arquivo se chama sum.cpp execute: g++ -Wall -O3 -g sum.cpp -o sum E execute ent\u00e3o programa via valgrind : valgrind --tool=callgrind ./sum O valgrind ir\u00e1 retornar algo como: ==3079146== Callgrind, a call-graph generating cache profiler ==3079146== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al. ==3079146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==3079146== Command: ./sum ==3079146== ==3079146== For interactive control, run 'callgrind_control -h'. 1 1 ==3079146== ==3079146== Events : Ir ==3079146== Collected : 50553796 ==3079146== ==3079146== I refs: 50,553,796 Onde 3079146 \u00e9 o PID da execu\u00e7\u00e3o. Na sua m\u00e1quina ser\u00e1 um outro valor. Ele tamb\u00e9m gerou um arquivo callgrind.out.{PID} . Execute a ferramenta callgrind_annotate para verificar o resultado do profiling. callgrind_annotate callgrind.out.3079146 sum.cpp E seu output ser\u00e1 como segue: -------------------------------------------------------------------------------- Profile data file 'callgrind.out.3079146' (creator: callgrind-3.15.0) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 10863316 Trigger: Program termination Profiled target: ./sum (PID 3079146, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: sum.cpp Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 50,553,796 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 31,479,818 sum.cpp:main [/home/user/andre/profile/sum] 16,777,221 /usr/include/c++/9/bits/stl_algobase.h:main 948,840 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 554,233 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so] 273,488 /build/glibc-eX1tMB/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object 117,179 /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so] -------------------------------------------------------------------------------- -- User-annotated source: sum.cpp -------------------------------------------------------------------------------- Ir . #include<iostream> . #include<algorithm> . using namespace std; . . constexpr int M = 2048; . constexpr int N = 2048; . . double naive_sum(const double a[][N]){ 1 double sum = 0.0; 6,144 for(int j = 0; j < N; ++j) { 12,587,008 for(int i = 0; i < M; ++i) 4,194,304 sum += a[i][j]; . } . return sum; . } . . double improved_sum(const double a[][N]) { 4,097 double sum = 0.0; 8,192 for(int i = 0; i < M; ++i) 4,194,304 for(int j = 0; j < N; ++j) 10,485,760 sum +=a[i][j]; . return sum; . } . 5 int main() { . static double a[M][N]; . fill_n(&a[0][0], M*N, 1.0 / (M*N)); . cout << naive_sum(a) << endl; . static double b[M][N]; . fill_n(&b[0][0], M*N, 1.0 / (M*N)); . cout << improved_sum(b) << endl; . return 0; 6 } -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 31,479,821 events annotated O que voc\u00ea pode dizer sobre o desempenho do programa? Por que h\u00e1 diferen\u00e7a de instruction fetch (IR) entre naive_sum e improved_sum ? Tip Dica: Verifique a discuss\u00e3o no StackOverflow sobre isso. Neste link https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra","title":"Warm-up: O problema da soma de uma matriz"},{"location":"aulas/04-profiling/#distancia-euclides-ingenuo","text":"Compile o c\u00f3digo-fonte da implementa\u00e7\u00e3o ing\u00eanua que fizemos na aula passada, com profiling habilitado para medir os tempos de execu\u00e7\u00e3o. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, execute o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) O que tomou mais tempo de execu\u00e7\u00e3o da vers\u00e3o ing\u00eanua?","title":"Dist\u00e2ncia: Euclides ing\u00eanuo"},{"location":"aulas/04-profiling/#medindo-os-tempos-no-seu-proprio-programa","text":"Voc\u00ea vai perceber, ao executar a atividade anterior, que boa parte do tempo \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medindo os tempos no seu pr\u00f3prio programa"},{"location":"aulas/04-profiling/#matrizes-versao-2","text":"Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"Matrizes (vers\u00e3o 2)"},{"location":"aulas/05-heuristicas/","text":"05 - Heur\u00edsticas \u00b6 A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria . Resumo do problema \u00b6 Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt . Mais caro primeiro \u00b6 A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct . Mais leve primeiro \u00b6 Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior. Analisando nossas heur\u00edsticas \u00b6 Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#05-heuristicas","text":"A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria .","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#resumo-do-problema","text":"Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt .","title":"Resumo do problema"},{"location":"aulas/05-heuristicas/#mais-caro-primeiro","text":"A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct .","title":"Mais caro primeiro"},{"location":"aulas/05-heuristicas/#mais-leve-primeiro","text":"Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior.","title":"Mais leve primeiro"},{"location":"aulas/05-heuristicas/#analisando-nossas-heuristicas","text":"Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"Analisando nossas heur\u00edsticas"},{"location":"aulas/06-aleatorizacao/","text":"06 - Algoritmos Aleatorizados \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Iniciando com RNGs \u00b6 Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o? Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria \u00b6 Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula. Algoritmos Gen\u00e9ticos \u00b6 Nesta aula tamb\u00e9m abordamos o trade-off entre exploration e exploitation. Para isso, foi poss\u00edvel conhecer uma implementa\u00e7\u00e3o por algoritmos gen\u00e9ticos para o problema da Mochila Bin\u00e1ria em Python. Caso queira executar essa solu\u00e7\u00e3o, acesse esse link . Question Implemente essa solu\u00e7\u00e3o em C++. Explore as taxas de sele\u00e7\u00e3o, cross-over e muta\u00e7\u00e3o. Escreva um pequeno relat\u00f3rio (de at\u00e9 1 p\u00e1gina) e comente os principais pontos observados. A entrega desse exerc\u00edcio pode lhe render 0,5 ponto extra, a ser computado ao final da disciplina.","title":"06 - Aleatoriza\u00e7\u00e3o"},{"location":"aulas/06-aleatorizacao/#06-algoritmos-aleatorizados","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a?","title":"06 - Algoritmos Aleatorizados"},{"location":"aulas/06-aleatorizacao/#iniciando-com-rngs","text":"Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o?","title":"Iniciando com RNGs"},{"location":"aulas/06-aleatorizacao/#construindo-uma-solucao-inteira-aleatoria","text":"Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria"},{"location":"aulas/06-aleatorizacao/#algoritmos-geneticos","text":"Nesta aula tamb\u00e9m abordamos o trade-off entre exploration e exploitation. Para isso, foi poss\u00edvel conhecer uma implementa\u00e7\u00e3o por algoritmos gen\u00e9ticos para o problema da Mochila Bin\u00e1ria em Python. Caso queira executar essa solu\u00e7\u00e3o, acesse esse link . Question Implemente essa solu\u00e7\u00e3o em C++. Explore as taxas de sele\u00e7\u00e3o, cross-over e muta\u00e7\u00e3o. Escreva um pequeno relat\u00f3rio (de at\u00e9 1 p\u00e1gina) e comente os principais pontos observados. A entrega desse exerc\u00edcio pode lhe render 0,5 ponto extra, a ser computado ao final da disciplina.","title":"Algoritmos Gen\u00e9ticos"},{"location":"aulas/07-busca-local/","text":"07 - Busca local \u00b6 Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o. Solu\u00e7\u00e3o aleatorizada \u00b6 Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochila se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas. Busca local \u00b6 Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva. Mochila cheia \u00b6 Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorra novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"07 - Busca Local"},{"location":"aulas/07-busca-local/#07-busca-local","text":"Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.","title":"07 - Busca local"},{"location":"aulas/07-busca-local/#solucao-aleatorizada","text":"Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochila se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas.","title":"Solu\u00e7\u00e3o aleatorizada"},{"location":"aulas/07-busca-local/#busca-local","text":"Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva.","title":"Busca local"},{"location":"aulas/07-busca-local/#mochila-cheia","text":"Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorra novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa?","title":"Mochila cheia"},{"location":"aulas/07-busca-local/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"Fechamento"},{"location":"aulas/08-busca-global/","text":"08 - Busca exaustiva \u00b6 Pseudo-c\u00f3digo \u00b6 Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada. Implementa\u00e7\u00e3o \u00b6 Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"08 - Busca Exaustiva"},{"location":"aulas/08-busca-global/#08-busca-exaustiva","text":"","title":"08 - Busca exaustiva"},{"location":"aulas/08-busca-global/#pseudo-codigo","text":"Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.","title":"Pseudo-c\u00f3digo"},{"location":"aulas/08-busca-global/#implementacao","text":"Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ?","title":"Implementa\u00e7\u00e3o"},{"location":"aulas/08-busca-global/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"Fechamento"},{"location":"aulas/09-busca-global-II/","text":"09 - Compara\u00e7\u00e3o de resultados \u00b6 J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados. At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido? \u00b6 O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas? \u00b6 Vale a pena esperar pela busca global? At\u00e9 que ponto? \u00b6 Formulando a pergunta com precis\u00e3o \u00b6 Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Como voc\u00ea usaria um gerador para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia. Implementando de maneira reprodut\u00edvel \u00b6 Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : reveja a nossa aula 01 e relembre como criar testes reprodut\u00edveis. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado. Question Usando as tabelas e gr\u00e1ficos criados, responda \u00e0 pergunta escolhida no in\u00edcio do handout.","title":"09 - Compara\u00e7\u00e3o de desempenho"},{"location":"aulas/09-busca-global-II/#09-comparacao-de-resultados","text":"J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados.","title":"09 - Compara\u00e7\u00e3o de resultados"},{"location":"aulas/09-busca-global-II/#ate-qual-tamanho-de-mochila-a-busca-global-resolve-rapido","text":"","title":"At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido?"},{"location":"aulas/09-busca-global-II/#o-algoritmo-de-busca-local-e-melhor-que-as-heuristicas","text":"","title":"O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas?"},{"location":"aulas/09-busca-global-II/#vale-a-pena-esperar-pela-busca-global-ate-que-ponto","text":"","title":"Vale a pena esperar pela busca global? At\u00e9 que ponto?"},{"location":"aulas/09-busca-global-II/#formulando-a-pergunta-com-precisao","text":"Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Como voc\u00ea usaria um gerador para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia.","title":"Formulando a pergunta com precis\u00e3o"},{"location":"aulas/09-busca-global-II/#implementando-de-maneira-reprodutivel","text":"Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : reveja a nossa aula 01 e relembre como criar testes reprodut\u00edveis. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado. Question Usando as tabelas e gr\u00e1ficos criados, responda \u00e0 pergunta escolhida no in\u00edcio do handout.","title":"Implementando de maneira reprodut\u00edvel"},{"location":"aulas/10-branch-and-bound/","text":"10 - Branch and Bound \u00b6 Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo. Um bound simples: ignorar peso \u00b6 Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Anote abaixo os contadores e interprete seu resultado. Analisando nosso bound \u00b6 Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima. Implementa\u00e7\u00e3o eficiente do bound \u00b6 Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o. Avan\u00e7ado: o qu\u00e3o justo \u00e9 um bound? \u00b6 Podemos medir qu\u00e3o justo \u00e9 um bound verificando a diferen\u00e7a entre seu valor e o valor real da melhor solu\u00e7\u00e3o da sub\u00e1rvore de recurs\u00e3o atual. Ou seja, comparamos nossa estimativa otimista com o que aconteceu de verdade ao examinar todas essas solu\u00e7\u00f5es. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima.","title":"10 - Branch and Bound"},{"location":"aulas/10-branch-and-bound/#10-branch-and-bound","text":"Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo.","title":"10 - Branch and Bound"},{"location":"aulas/10-branch-and-bound/#um-bound-simples-ignorar-peso","text":"Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Anote abaixo os contadores e interprete seu resultado.","title":"Um bound simples: ignorar peso"},{"location":"aulas/10-branch-and-bound/#analisando-nosso-bound","text":"Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima.","title":"Analisando nosso bound"},{"location":"aulas/10-branch-and-bound/#implementacao-eficiente-do-bound","text":"Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o.","title":"Implementa\u00e7\u00e3o eficiente do bound"},{"location":"aulas/10-branch-and-bound/#avancado-o-quao-justo-e-um-bound","text":"Podemos medir qu\u00e3o justo \u00e9 um bound verificando a diferen\u00e7a entre seu valor e o valor real da melhor solu\u00e7\u00e3o da sub\u00e1rvore de recurs\u00e3o atual. Ou seja, comparamos nossa estimativa otimista com o que aconteceu de verdade ao examinar todas essas solu\u00e7\u00f5es. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima.","title":"Avan\u00e7ado: o qu\u00e3o justo \u00e9 um bound?"},{"location":"aulas/11-paralelismo/","text":"12 - Introdu\u00e7\u00e3o a paralelismo \u00b6 OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo. Fizemos em sala de aula uma s\u00e9rie de programas b\u00e1sicos no OpenMP e agora \u00e9 a hora de praticar. C\u00e1lculo do PI por meio de uma s\u00e9rie infinita de Leibniz \u00b6 Voc\u00ea sabia que \u00e9 poss\u00edvel calcular o valor do PI por meio de uma s\u00e9rie infinita de Leibniz? Veja abaixo: 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\dots = \\frac{\\pi}{4} 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\dots = \\frac{\\pi}{4} \\sum_{0}^{\\infty} = \\frac{(-1)^n}{2n + 1} = \\frac{\\pi}{4} \\sum_{0}^{\\infty} = \\frac{(-1)^n}{2n + 1} = \\frac{\\pi}{4} Essa s\u00e9rie converge muito lentamente, o que \u00e9 bom para n\u00f3s. Sua tarefa \u00b6 Implemente a vers\u00e3o serial do c\u00e1lculo do PI a partir da s\u00e9rie infinita de Leibniz. Fa\u00e7a n = 1000000000 . Ap\u00f3s implementar a vers\u00e3o serial e calcular o tempo de sua execu\u00e7\u00e3o, implemente a vers\u00e3o em openmp . Voc\u00ea deve fazer sua implementa\u00e7\u00e3o de duas formas: a) A primeira implementa\u00e7\u00e3o voc\u00ea deve trabalhar com 2 threads e a partir do id da thread, voc\u00ea deve dividir a soma em duas partes, cada thread executando a sua por\u00e7\u00e3o. b) A segunda implementa\u00e7\u00e3o voc\u00ea deve trabalhar com for do openmp e tratar como uma redu\u00e7\u00e3o do valor de PI. Calcule o tempo de execu\u00e7\u00e3o. O speedup \u00e9 uma m\u00e9trica que representa a raz\u00e3o entre o tempo de execu\u00e7\u00e3o de um programa sequencial e o tempo de execu\u00e7\u00e3o de sua vers\u00e3o paralela. Por isso, trata-se de uma boa medida para avaliarmos quantitativamente a melhoria trazida pela vers\u00e3o paralela de um programa paralelo em rela\u00e7\u00e3o \u00e0 sua vers\u00e3o sequencial. Calcule tamb\u00e9m o speed up de cada uma das solu\u00e7\u00f5es. Tasks (tarefas) em OpenMP \u00b6 Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o agendadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? 1 4, uma para cada thread Nenhuma das anteriores Details Como cada thread roda o c\u00f3digo da regi\u00e3o paralela, cada uma cria exatamente um tarefa. Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . Assim conseguimos criar c\u00f3digo leg\u00edvel e que deixa bem claro quantas e quais tarefas s\u00e3o criadas. #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Somente lendo o c\u00f3digo acima, responda as quest\u00f5es abaixo. Question Quantas tarefas s\u00e3o criadas no exemplo acima? 1 N, uma para cada thread Nenhuma das anteriores Question A(s) tarefa(s) criada(s) roda(m) em qual thread? 0 1 Imposs\u00edvel dizer. Em cada execu\u00e7\u00e3o rodar\u00e1 em uma thread diferente. Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas. Details Sequencial demora a soma dos tempos das duas fun\u00e7\u00f5es. Paralelo demora o tempo da maior delas.","title":"12 - Introdu\u00e7\u00e3o a paralelismo"},{"location":"aulas/11-paralelismo/#12-introducao-a-paralelismo","text":"OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo. Fizemos em sala de aula uma s\u00e9rie de programas b\u00e1sicos no OpenMP e agora \u00e9 a hora de praticar.","title":"12 - Introdu\u00e7\u00e3o a paralelismo"},{"location":"aulas/11-paralelismo/#calculo-do-pi-por-meio-de-uma-serie-infinita-de-leibniz","text":"Voc\u00ea sabia que \u00e9 poss\u00edvel calcular o valor do PI por meio de uma s\u00e9rie infinita de Leibniz? Veja abaixo: 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\dots = \\frac{\\pi}{4} 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\dots = \\frac{\\pi}{4} \\sum_{0}^{\\infty} = \\frac{(-1)^n}{2n + 1} = \\frac{\\pi}{4} \\sum_{0}^{\\infty} = \\frac{(-1)^n}{2n + 1} = \\frac{\\pi}{4} Essa s\u00e9rie converge muito lentamente, o que \u00e9 bom para n\u00f3s.","title":"C\u00e1lculo do PI por meio de uma s\u00e9rie infinita de Leibniz"},{"location":"aulas/11-paralelismo/#sua-tarefa","text":"Implemente a vers\u00e3o serial do c\u00e1lculo do PI a partir da s\u00e9rie infinita de Leibniz. Fa\u00e7a n = 1000000000 . Ap\u00f3s implementar a vers\u00e3o serial e calcular o tempo de sua execu\u00e7\u00e3o, implemente a vers\u00e3o em openmp . Voc\u00ea deve fazer sua implementa\u00e7\u00e3o de duas formas: a) A primeira implementa\u00e7\u00e3o voc\u00ea deve trabalhar com 2 threads e a partir do id da thread, voc\u00ea deve dividir a soma em duas partes, cada thread executando a sua por\u00e7\u00e3o. b) A segunda implementa\u00e7\u00e3o voc\u00ea deve trabalhar com for do openmp e tratar como uma redu\u00e7\u00e3o do valor de PI. Calcule o tempo de execu\u00e7\u00e3o. O speedup \u00e9 uma m\u00e9trica que representa a raz\u00e3o entre o tempo de execu\u00e7\u00e3o de um programa sequencial e o tempo de execu\u00e7\u00e3o de sua vers\u00e3o paralela. Por isso, trata-se de uma boa medida para avaliarmos quantitativamente a melhoria trazida pela vers\u00e3o paralela de um programa paralelo em rela\u00e7\u00e3o \u00e0 sua vers\u00e3o sequencial. Calcule tamb\u00e9m o speed up de cada uma das solu\u00e7\u00f5es.","title":"Sua tarefa"},{"location":"aulas/11-paralelismo/#tasks-tarefas-em-openmp","text":"Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o agendadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? 1 4, uma para cada thread Nenhuma das anteriores Details Como cada thread roda o c\u00f3digo da regi\u00e3o paralela, cada uma cria exatamente um tarefa. Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . Assim conseguimos criar c\u00f3digo leg\u00edvel e que deixa bem claro quantas e quais tarefas s\u00e3o criadas. #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Somente lendo o c\u00f3digo acima, responda as quest\u00f5es abaixo. Question Quantas tarefas s\u00e3o criadas no exemplo acima? 1 N, uma para cada thread Nenhuma das anteriores Question A(s) tarefa(s) criada(s) roda(m) em qual thread? 0 1 Imposs\u00edvel dizer. Em cada execu\u00e7\u00e3o rodar\u00e1 em uma thread diferente. Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas. Details Sequencial demora a soma dos tempos das duas fun\u00e7\u00f5es. Paralelo demora o tempo da maior delas.","title":"Tasks (tarefas) em OpenMP"},{"location":"aulas/12-efeitos-colaterais/","text":"15 - Scheduling e Efeitos Colaterais \u00b6 Scheduling \u00b6 Vamos come\u00e7ar compreendendo melhor os schedulers que existem no openmp. No github, obtenha o arquivo omp_schedulers.cpp , compile e execute-o. Voc\u00ea dever\u00e1 obter um output similar ao abaixo. Verifique na documenta\u00e7\u00e3o do OpenMP ( link ) e busque compreender melhor como funciona cada scheduler. default : **************** **************** **************** **************** schedule ( static ) : **************** **************** **************** **************** schedule ( static , 4 ) : **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** schedule ( static , 8 ) : ******** ******** ******** ******** ******** ******** ******** ******** schedule ( dynamic ) : ** ******** ** ***** * ** ****** * * **** * * ** * * * * * * * * * ** * * * * * * ** ** * * ** * * * schedule ( dynamic , 1 ) : * ** ** * ** * * * * * ** * * *** * * * ******* * * * * * * * * ** * * ** * * * * * *** ** * * * * * * * * * * schedule ( dynamic , 4 ) : **** ******************************** ******************** **** **** schedule ( dynamic , 8 ) : ******** **************************************** ******** ******** schedule ( guided ) : **************** **************** *************** ************ ***** schedule ( guided , 2 ) : **************** *************************** ************ ********* schedule ( guided , 4 ) : **************** ************************************ ************ schedule ( guided , 8 ) : ************ ************************ ********* **************** *** schedule ( auto ) : **************** **************** **************** **************** schedule ( runtime ) : **************** **************** **************** **************** Revisitando Parallel for , tasks e sections \u00b6 Agora que j\u00e1 conseguimos resolver problemas simples usando tr\u00eas abordagens diferentes, vamos aumentar a complexidade dos problemas tratados. Vimos tr\u00eas abordagens parallel for - \u00fatil para quando precisamos executar a mesma opera\u00e7\u00e3o em um conjunto grande de dados. tasks - \u00fatil para paralelizar tarefas heterog\u00eaneas. sections - permite paralelizar tarefas heterog\u00eanas, com o controle adicional que uma section \u00e9 executada apenas por uma thread. Teremos ent\u00e3o dois desafios relacionados a paralelizar programas que n\u00e3o s\u00e3o obviamente paraleliz\u00e1veis. C\u00e1lculo do pi recursivo \u00b6 Vamos iniciar com um c\u00f3digo recursivo para c\u00e1lculo do pi. Example Examine o c\u00f3digo em pi_recursivo.cpp . Procure entender bem o que est\u00e1 acontecendo antes de prosseguir. Question Onde est\u00e3o as oportunidades de paralelismo? O c\u00f3digo tem depend\u00eancias? Question Se o c\u00f3digo tiver depend\u00eancias, \u00e9 poss\u00edvel refator\u00e1-lo para elimin\u00e1-las? Question Quantas n\u00edveis de chamadas recursivas s\u00e3o feitas? Quando o programa para de chamar recursivamente e faz sequencial? Vamos agora tentar paralelizar o programa usando as duas t\u00e9cnicas. Usando for paralelo \u00b6 Question Em quais linhas pode haver oportunidade para usar parallel for ? Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando for paralelo. Me\u00e7a seu tempo e anote. Example O n\u00famero MIN_BLK afeta seu algoritmo? \u00c9 melhor aument\u00e1-lo ou diminu\u00ed-lo? Question Os ganhos de desempenho foram significativos? Question Como voc\u00ea fez o paralelismo? Precisou definir o n\u00famero do for manualmente ou conseguiu realizar a divis\u00e3o automaticamente? Comente abaixo sua implementa\u00e7\u00e3o. Usando task \u00b6 Agora vamos usar task . Neste caso \u00e9 vamos adotar a seguinte estrat\u00e9gia: usaremos tarefas para paralelizar as chamadas recursivas feitas em pi_recursivo.cpp . Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando tarefas. Me\u00e7a seu tempo e anote. Dica : se voc\u00ea precisar esperar tarefas pode usar a diretiva #pragma omp taskwait . Ela espera por todas as tarefas criadas pela thread atual. Question Os ganhos de desempenho foram significativos? Question Quantas tarefas foram criadas? Voc\u00ea escolheu essa valor como? Example Tente n\u00fameros diferentes de tarefas e verifique se o desempenho melhora ou piora. Anote suas conclus\u00f5es abaixo. Compara\u00e7\u00e3o \u00b6 Question Compare seus resultados das duas abordagens. Anote abaixo seus resultados. Warning \u00c9 poss\u00edvel conseguir tempos muito parecidos com ambas, ent\u00e3o se uma delas ficou muito mais lenta \u00e9 hora de rever o que foi feito. Efeitos Colaterais \u00b6 Agora que j\u00e1 conseguimos resolver um problema um pouco mais complexo usando abordagens diferentes, vamos aumentar um pouco mais a complexidade dos problemas tratados. No c\u00f3digo pi_recursivo.cpp t\u00ednhamos uma vari\u00e1vel global que podia ser eliminada do c\u00f3digo mudando a fun\u00e7\u00e3o recursiva. Isso, por\u00e9m, nem sempre \u00e9 poss\u00edvel e precisamos lidar com estas situa\u00e7\u00f5es. Um primeiro teste \u00b6 Vamos iniciar trabalhando com o seguinte trecho de c\u00f3digo (arquivo vetor_insert.cpp ): std :: vector < double > vec ; for ( int i = 0 ; i < N ; i ++ ) { vec . push_back ( conta_complexa ( i )); } Vamos supor agora que usaremos o seguinte comando para paralelizar o c\u00f3digo acima usando OpenMP: #pragma omp parallel for Question A vari\u00e1vel i \u00e9 shared private firstprivate Question A vari\u00e1vel vec \u00e9 shared private firstprivate Question O c\u00f3digo paralelizado rodaria sem dar erros? Os resultados seriam os esperados? Sim, o vector \u00e9 capaz de gerenciar os acessos simult\u00e2neos O c\u00f3digo acima roda sem erros, mas o conte\u00fado do vetor pode n\u00e3o estar correto ao fim do programa N\u00e3o, o c\u00f3digo acima d\u00e1 erro ao executar. Resposta Rode e veja o que acontece ;) Progress Clique ap\u00f3s rodar o programa Agora que vimos o que acontece, vamos consertar isso! Danger Nosso c\u00f3digo d\u00e1 erro pois a opera\u00e7\u00e3o push_back modifica o vetor ! Vamos ver ent\u00e3o duas abordagens importantes para contornar esse problema. Se\u00e7\u00f5es cr\u00edticas \u00b6 Antes de come\u00e7ar, vamos aprender mais um aspecto de OpenMP: diretivas para compartilhamento de dados. J\u00e1 vimos as 3 principais op\u00e7\u00f5es: shared - compartilhado entre threads private - privados entre threads firstprivate - Especifica que cada thread deve ter sua pr\u00f3pria inst\u00e2ncia de uma vari\u00e1vel e que a vari\u00e1vel deve ser inicializada com o valor da vari\u00e1vel antes da se\u00e7\u00e3o paralela. Podemos for\u00e7ar a especifica\u00e7\u00e3o de diretivas de compartilhamento para todas as vari\u00e1veis usadas nas constru\u00e7\u00f5es omp parallel , omp task e omp parallel for . Tip Ao adicionarmos default(none) logo ap\u00f3s as diretivas acima precisaremos especificar, para cada vari\u00e1vel usada, sua diretiva de compartilhamento. Isso torna muito mais f\u00e1cil identificar casos de compartilhamento indevido de dados. A partir desse ponto estaremos supondo que todo c\u00f3digo criado usar\u00e1 default(none) . A primeira abordagem usada ter\u00e1 a miss\u00e3o de indicar que um conjunto de linhas cont\u00e9m uma opera\u00e7\u00e3o que possui efeitos colaterais. Dessa maneira, podemos evitar conflitos se s\u00f3 permitirmos que essa regi\u00e3o rode em uma thread por vez . Fazemos isso usando a diretiva omp critical : #pragma omp critical { // c\u00f3digo aqui dentro roda somente em uma thread por vez. } Se duas threads chegam ao mesmo tempo no bloco critical , uma delas ficar\u00e1 esperando at\u00e9 a outra acabar o bloco. Quando isso ocorrer a thread que esperou poder\u00e1 prosseguir. Vamos tentar aplicar isso ao c\u00f3digo de vetor_insert.cpp . Example Use omp critical para solucionar os problemas de concorr\u00eancia do c\u00f3digo acima. Question Escreva abaixo o tempo que seu c\u00f3digo levou para rodar. Progress Clique ap\u00f3s rodar seu c\u00f3digo Se sua implementa\u00e7\u00e3o se parecer com o c\u00f3digo abaixo, ent\u00e3o \u00e9 bem prov\u00e1vel que a vers\u00e3o paralela na verdade tenha demorado o mesmo tempo ou mais que o original. .... #pragma omp parallel for default(none) shared(vec) for ( int i = 0 ; i < N ; i ++ ) { #pragma omp critical { vec . push_back ( conta_complexa ( i )); } } .... Question Analise o c\u00f3digo novamente e tente explicar por que o programa n\u00e3o ganhou velocidade. Resposta A opera\u00e7\u00e3o que produz efeitos colaterais \u00e9 vec.push_back , mas nossa se\u00e7\u00e3o cr\u00edtica envolve tamb\u00e9m a chamada conta_complexa(i) . Example Modifique seu c\u00f3digo de acordo com a resposta acima. Me\u00e7a o desempenho e veja que agora h\u00e1 melhora. Vamos analisar agora a ordem dos dados em vec . Question A ordem se mant\u00e9m igual ao programa sequencial? Voc\u00ea consegue explicar por que? Resposta N\u00e3o se mant\u00e9m. Cada thread chega ao push_back em um momento diferente, logo a ordem em que os dados s\u00e3o adicionados no vetor muda. Manejo de conflitos usando pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Se\u00e7\u00f5es cr\u00edticas s\u00e3o muito \u00fateis quando n\u00e3o conseguimos evitar o compartilhamento de dados. Por\u00e9m, elas s\u00e3o caras e e feitas especialmente para situa\u00e7\u00f5es em que regi\u00e3o cr\u00edtica \u00e9 pequena e chamada um n\u00famero relativamente pequeno de vezes. Como regra, desejamos entrar na regi\u00e3o cr\u00edtica o menor n\u00famero poss\u00edvel de vezes. Question Reveja o c\u00f3digo do inicial da se\u00e7\u00e3o de efeitos colaterais. Seria poss\u00edvel reescrev\u00ea-lo para n\u00e3o usar push_back ? Resposta Sim, bastaria alocar o vetor com tamanho N ao cri\u00e1-lo. Assim poder\u00edamos atribuir conta_complexa direto para a posi\u00e7\u00e3o de mem\u00f3ria desejada. A estrat\u00e9gia acima \u00e9 muito importante em alto desempenho e representa uma maneira de evitar se\u00e7\u00f5es cr\u00edticas e sincroniza\u00e7\u00e3o. \u00c9 sempre melhor alocar mem\u00f3ria em blocos grandes antes do paralelismo do que alocar mem\u00f3ria frequentemente dentro de regi\u00f5es paralelas. Note que fizemos isso na parte de tarefas: ao criarmos vari\u00e1veis para cada tarefa preencher evitamos a necessidade de usar sincroniza\u00e7\u00e3o. Example Modifique o programa para usar a ideia da quest\u00e3o anterior. Me\u00e7a o desempenho e verifique que tudo funciona normalmente e mais r\u00e1pido que o original. Dica \u00b6 A Microsoft possui uma p\u00e1gina bem completa sobre o OpenMP . Vale a pena conferir neste link .","title":"15 - Scheduling e  Efeitos Colaterais"},{"location":"aulas/12-efeitos-colaterais/#15-scheduling-e-efeitos-colaterais","text":"","title":"15 - Scheduling e  Efeitos Colaterais"},{"location":"aulas/12-efeitos-colaterais/#scheduling","text":"Vamos come\u00e7ar compreendendo melhor os schedulers que existem no openmp. No github, obtenha o arquivo omp_schedulers.cpp , compile e execute-o. Voc\u00ea dever\u00e1 obter um output similar ao abaixo. Verifique na documenta\u00e7\u00e3o do OpenMP ( link ) e busque compreender melhor como funciona cada scheduler. default : **************** **************** **************** **************** schedule ( static ) : **************** **************** **************** **************** schedule ( static , 4 ) : **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** schedule ( static , 8 ) : ******** ******** ******** ******** ******** ******** ******** ******** schedule ( dynamic ) : ** ******** ** ***** * ** ****** * * **** * * ** * * * * * * * * * ** * * * * * * ** ** * * ** * * * schedule ( dynamic , 1 ) : * ** ** * ** * * * * * ** * * *** * * * ******* * * * * * * * * ** * * ** * * * * * *** ** * * * * * * * * * * schedule ( dynamic , 4 ) : **** ******************************** ******************** **** **** schedule ( dynamic , 8 ) : ******** **************************************** ******** ******** schedule ( guided ) : **************** **************** *************** ************ ***** schedule ( guided , 2 ) : **************** *************************** ************ ********* schedule ( guided , 4 ) : **************** ************************************ ************ schedule ( guided , 8 ) : ************ ************************ ********* **************** *** schedule ( auto ) : **************** **************** **************** **************** schedule ( runtime ) : **************** **************** **************** ****************","title":"Scheduling"},{"location":"aulas/12-efeitos-colaterais/#revisitando-parallel-for-tasks-e-sections","text":"Agora que j\u00e1 conseguimos resolver problemas simples usando tr\u00eas abordagens diferentes, vamos aumentar a complexidade dos problemas tratados. Vimos tr\u00eas abordagens parallel for - \u00fatil para quando precisamos executar a mesma opera\u00e7\u00e3o em um conjunto grande de dados. tasks - \u00fatil para paralelizar tarefas heterog\u00eaneas. sections - permite paralelizar tarefas heterog\u00eanas, com o controle adicional que uma section \u00e9 executada apenas por uma thread. Teremos ent\u00e3o dois desafios relacionados a paralelizar programas que n\u00e3o s\u00e3o obviamente paraleliz\u00e1veis.","title":"Revisitando Parallel for, tasks e sections"},{"location":"aulas/12-efeitos-colaterais/#calculo-do-pi-recursivo","text":"Vamos iniciar com um c\u00f3digo recursivo para c\u00e1lculo do pi. Example Examine o c\u00f3digo em pi_recursivo.cpp . Procure entender bem o que est\u00e1 acontecendo antes de prosseguir. Question Onde est\u00e3o as oportunidades de paralelismo? O c\u00f3digo tem depend\u00eancias? Question Se o c\u00f3digo tiver depend\u00eancias, \u00e9 poss\u00edvel refator\u00e1-lo para elimin\u00e1-las? Question Quantas n\u00edveis de chamadas recursivas s\u00e3o feitas? Quando o programa para de chamar recursivamente e faz sequencial? Vamos agora tentar paralelizar o programa usando as duas t\u00e9cnicas.","title":"C\u00e1lculo do pi recursivo"},{"location":"aulas/12-efeitos-colaterais/#usando-for-paralelo","text":"Question Em quais linhas pode haver oportunidade para usar parallel for ? Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando for paralelo. Me\u00e7a seu tempo e anote. Example O n\u00famero MIN_BLK afeta seu algoritmo? \u00c9 melhor aument\u00e1-lo ou diminu\u00ed-lo? Question Os ganhos de desempenho foram significativos? Question Como voc\u00ea fez o paralelismo? Precisou definir o n\u00famero do for manualmente ou conseguiu realizar a divis\u00e3o automaticamente? Comente abaixo sua implementa\u00e7\u00e3o.","title":"Usando for paralelo"},{"location":"aulas/12-efeitos-colaterais/#usando-task","text":"Agora vamos usar task . Neste caso \u00e9 vamos adotar a seguinte estrat\u00e9gia: usaremos tarefas para paralelizar as chamadas recursivas feitas em pi_recursivo.cpp . Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando tarefas. Me\u00e7a seu tempo e anote. Dica : se voc\u00ea precisar esperar tarefas pode usar a diretiva #pragma omp taskwait . Ela espera por todas as tarefas criadas pela thread atual. Question Os ganhos de desempenho foram significativos? Question Quantas tarefas foram criadas? Voc\u00ea escolheu essa valor como? Example Tente n\u00fameros diferentes de tarefas e verifique se o desempenho melhora ou piora. Anote suas conclus\u00f5es abaixo.","title":"Usando task"},{"location":"aulas/12-efeitos-colaterais/#comparacao","text":"Question Compare seus resultados das duas abordagens. Anote abaixo seus resultados. Warning \u00c9 poss\u00edvel conseguir tempos muito parecidos com ambas, ent\u00e3o se uma delas ficou muito mais lenta \u00e9 hora de rever o que foi feito.","title":"Compara\u00e7\u00e3o"},{"location":"aulas/12-efeitos-colaterais/#efeitos-colaterais","text":"Agora que j\u00e1 conseguimos resolver um problema um pouco mais complexo usando abordagens diferentes, vamos aumentar um pouco mais a complexidade dos problemas tratados. No c\u00f3digo pi_recursivo.cpp t\u00ednhamos uma vari\u00e1vel global que podia ser eliminada do c\u00f3digo mudando a fun\u00e7\u00e3o recursiva. Isso, por\u00e9m, nem sempre \u00e9 poss\u00edvel e precisamos lidar com estas situa\u00e7\u00f5es.","title":"Efeitos Colaterais"},{"location":"aulas/12-efeitos-colaterais/#um-primeiro-teste","text":"Vamos iniciar trabalhando com o seguinte trecho de c\u00f3digo (arquivo vetor_insert.cpp ): std :: vector < double > vec ; for ( int i = 0 ; i < N ; i ++ ) { vec . push_back ( conta_complexa ( i )); } Vamos supor agora que usaremos o seguinte comando para paralelizar o c\u00f3digo acima usando OpenMP: #pragma omp parallel for Question A vari\u00e1vel i \u00e9 shared private firstprivate Question A vari\u00e1vel vec \u00e9 shared private firstprivate Question O c\u00f3digo paralelizado rodaria sem dar erros? Os resultados seriam os esperados? Sim, o vector \u00e9 capaz de gerenciar os acessos simult\u00e2neos O c\u00f3digo acima roda sem erros, mas o conte\u00fado do vetor pode n\u00e3o estar correto ao fim do programa N\u00e3o, o c\u00f3digo acima d\u00e1 erro ao executar. Resposta Rode e veja o que acontece ;) Progress Clique ap\u00f3s rodar o programa Agora que vimos o que acontece, vamos consertar isso! Danger Nosso c\u00f3digo d\u00e1 erro pois a opera\u00e7\u00e3o push_back modifica o vetor ! Vamos ver ent\u00e3o duas abordagens importantes para contornar esse problema.","title":"Um primeiro teste"},{"location":"aulas/12-efeitos-colaterais/#secoes-criticas","text":"Antes de come\u00e7ar, vamos aprender mais um aspecto de OpenMP: diretivas para compartilhamento de dados. J\u00e1 vimos as 3 principais op\u00e7\u00f5es: shared - compartilhado entre threads private - privados entre threads firstprivate - Especifica que cada thread deve ter sua pr\u00f3pria inst\u00e2ncia de uma vari\u00e1vel e que a vari\u00e1vel deve ser inicializada com o valor da vari\u00e1vel antes da se\u00e7\u00e3o paralela. Podemos for\u00e7ar a especifica\u00e7\u00e3o de diretivas de compartilhamento para todas as vari\u00e1veis usadas nas constru\u00e7\u00f5es omp parallel , omp task e omp parallel for . Tip Ao adicionarmos default(none) logo ap\u00f3s as diretivas acima precisaremos especificar, para cada vari\u00e1vel usada, sua diretiva de compartilhamento. Isso torna muito mais f\u00e1cil identificar casos de compartilhamento indevido de dados. A partir desse ponto estaremos supondo que todo c\u00f3digo criado usar\u00e1 default(none) . A primeira abordagem usada ter\u00e1 a miss\u00e3o de indicar que um conjunto de linhas cont\u00e9m uma opera\u00e7\u00e3o que possui efeitos colaterais. Dessa maneira, podemos evitar conflitos se s\u00f3 permitirmos que essa regi\u00e3o rode em uma thread por vez . Fazemos isso usando a diretiva omp critical : #pragma omp critical { // c\u00f3digo aqui dentro roda somente em uma thread por vez. } Se duas threads chegam ao mesmo tempo no bloco critical , uma delas ficar\u00e1 esperando at\u00e9 a outra acabar o bloco. Quando isso ocorrer a thread que esperou poder\u00e1 prosseguir. Vamos tentar aplicar isso ao c\u00f3digo de vetor_insert.cpp . Example Use omp critical para solucionar os problemas de concorr\u00eancia do c\u00f3digo acima. Question Escreva abaixo o tempo que seu c\u00f3digo levou para rodar. Progress Clique ap\u00f3s rodar seu c\u00f3digo Se sua implementa\u00e7\u00e3o se parecer com o c\u00f3digo abaixo, ent\u00e3o \u00e9 bem prov\u00e1vel que a vers\u00e3o paralela na verdade tenha demorado o mesmo tempo ou mais que o original. .... #pragma omp parallel for default(none) shared(vec) for ( int i = 0 ; i < N ; i ++ ) { #pragma omp critical { vec . push_back ( conta_complexa ( i )); } } .... Question Analise o c\u00f3digo novamente e tente explicar por que o programa n\u00e3o ganhou velocidade. Resposta A opera\u00e7\u00e3o que produz efeitos colaterais \u00e9 vec.push_back , mas nossa se\u00e7\u00e3o cr\u00edtica envolve tamb\u00e9m a chamada conta_complexa(i) . Example Modifique seu c\u00f3digo de acordo com a resposta acima. Me\u00e7a o desempenho e veja que agora h\u00e1 melhora. Vamos analisar agora a ordem dos dados em vec . Question A ordem se mant\u00e9m igual ao programa sequencial? Voc\u00ea consegue explicar por que? Resposta N\u00e3o se mant\u00e9m. Cada thread chega ao push_back em um momento diferente, logo a ordem em que os dados s\u00e3o adicionados no vetor muda.","title":"Se\u00e7\u00f5es cr\u00edticas"},{"location":"aulas/12-efeitos-colaterais/#manejo-de-conflitos-usando-pre-alocacao-de-memoria","text":"Se\u00e7\u00f5es cr\u00edticas s\u00e3o muito \u00fateis quando n\u00e3o conseguimos evitar o compartilhamento de dados. Por\u00e9m, elas s\u00e3o caras e e feitas especialmente para situa\u00e7\u00f5es em que regi\u00e3o cr\u00edtica \u00e9 pequena e chamada um n\u00famero relativamente pequeno de vezes. Como regra, desejamos entrar na regi\u00e3o cr\u00edtica o menor n\u00famero poss\u00edvel de vezes. Question Reveja o c\u00f3digo do inicial da se\u00e7\u00e3o de efeitos colaterais. Seria poss\u00edvel reescrev\u00ea-lo para n\u00e3o usar push_back ? Resposta Sim, bastaria alocar o vetor com tamanho N ao cri\u00e1-lo. Assim poder\u00edamos atribuir conta_complexa direto para a posi\u00e7\u00e3o de mem\u00f3ria desejada. A estrat\u00e9gia acima \u00e9 muito importante em alto desempenho e representa uma maneira de evitar se\u00e7\u00f5es cr\u00edticas e sincroniza\u00e7\u00e3o. \u00c9 sempre melhor alocar mem\u00f3ria em blocos grandes antes do paralelismo do que alocar mem\u00f3ria frequentemente dentro de regi\u00f5es paralelas. Note que fizemos isso na parte de tarefas: ao criarmos vari\u00e1veis para cada tarefa preencher evitamos a necessidade de usar sincroniza\u00e7\u00e3o. Example Modifique o programa para usar a ideia da quest\u00e3o anterior. Me\u00e7a o desempenho e verifique que tudo funciona normalmente e mais r\u00e1pido que o original.","title":"Manejo de conflitos usando pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/12-efeitos-colaterais/#dica","text":"A Microsoft possui uma p\u00e1gina bem completa sobre o OpenMP . Vale a pena conferir neste link .","title":"Dica"},{"location":"aulas/13-efeitos-colaterais-II/","text":"16 - efeitos colaterais II \u00b6 Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o pi . Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlo . O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . Veja abaixo um resumo do algoritmo. sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de pi_montecarlo.cpp . Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de sum na sa\u00edda de erros. Adote N=100 000 . \u00c9 poss\u00edvel paralelizar o problema? \u00b6 Vamos iniciar pensando um pouco sobre o problema acima. Question O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo? Resposta O for paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel sum sendo usada na op\u00e7\u00e3o reduction Question Al\u00e9m da vari\u00e1vel sum , existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual? Resposta O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados. Progress Continuar Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada. Question Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios? Resposta Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando omp critical Question Se o for acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o? Resposta Desde de que os pares x,y sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema. Example Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do pi_montecarlo.cpp . Verifique que o valor de sum \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o . Question Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima. Progress Vamos discutir esse resultado juntos! Paralelizando processos inerentemente sequenciais \u00b6 Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all . Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4 : O for do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados. Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do for criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele. Primeira tentativa \u00b6 Question Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro seed fixo. O qu\u00ea acontece se usarmos o mesmo seed em todas as itera\u00e7\u00f5es? Como consertar isso? Resposta Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o seed ser baseado no i da itera\u00e7\u00e3o atual. Example Crie uma implementa\u00e7\u00e3o baseada na ideia acima. Question Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o. Question Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos? Progress Vamos discutir esse resultado. Segunda tentativa \u00b6 O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o RNG faz. Ele promete que dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade Ele n\u00e3o promete que, se criarmos v\u00e1rios RNG s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria. Vamos agora tentar uma nova ideia: Cada thread ir\u00e1 gerar N/NUM_THREADS n\u00fameros aleat\u00f3rios, atualizando sum com os pontos dentro do semi-c\u00edrculo. Question Como esta ideia melhora o algoritmo acima? Resposta Agora teremos NUM_THREADS sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma seed para cada, mas ao menos agora temos um n\u00famero pequeno de RNG s. Example Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. Question Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.","title":"16 - efeitos colaterais II"},{"location":"aulas/13-efeitos-colaterais-II/#16-efeitos-colaterais-ii","text":"Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o pi . Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlo . O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . Veja abaixo um resumo do algoritmo. sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de pi_montecarlo.cpp . Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de sum na sa\u00edda de erros. Adote N=100 000 .","title":"16 - efeitos colaterais II"},{"location":"aulas/13-efeitos-colaterais-II/#e-possivel-paralelizar-o-problema","text":"Vamos iniciar pensando um pouco sobre o problema acima. Question O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo? Resposta O for paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel sum sendo usada na op\u00e7\u00e3o reduction Question Al\u00e9m da vari\u00e1vel sum , existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual? Resposta O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados. Progress Continuar Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada. Question Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios? Resposta Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando omp critical Question Se o for acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o? Resposta Desde de que os pares x,y sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema. Example Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do pi_montecarlo.cpp . Verifique que o valor de sum \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o . Question Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima. Progress Vamos discutir esse resultado juntos!","title":"\u00c9 poss\u00edvel paralelizar o problema?"},{"location":"aulas/13-efeitos-colaterais-II/#paralelizando-processos-inerentemente-sequenciais","text":"Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all . Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4 : O for do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados. Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do for criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele.","title":"Paralelizando processos inerentemente sequenciais"},{"location":"aulas/13-efeitos-colaterais-II/#primeira-tentativa","text":"Question Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro seed fixo. O qu\u00ea acontece se usarmos o mesmo seed em todas as itera\u00e7\u00f5es? Como consertar isso? Resposta Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o seed ser baseado no i da itera\u00e7\u00e3o atual. Example Crie uma implementa\u00e7\u00e3o baseada na ideia acima. Question Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o. Question Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos? Progress Vamos discutir esse resultado.","title":"Primeira tentativa"},{"location":"aulas/13-efeitos-colaterais-II/#segunda-tentativa","text":"O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o RNG faz. Ele promete que dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade Ele n\u00e3o promete que, se criarmos v\u00e1rios RNG s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria. Vamos agora tentar uma nova ideia: Cada thread ir\u00e1 gerar N/NUM_THREADS n\u00fameros aleat\u00f3rios, atualizando sum com os pontos dentro do semi-c\u00edrculo. Question Como esta ideia melhora o algoritmo acima? Resposta Agora teremos NUM_THREADS sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma seed para cada, mas ao menos agora temos um n\u00famero pequeno de RNG s. Example Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. Question Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.","title":"Segunda tentativa"},{"location":"aulas/14-intro-gpu/","text":"17 - Introdu\u00e7\u00e3o a GPU \u00b6 Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas. Compila\u00e7\u00e3o para GPU \u00b6 Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. O nvcc e todas as bibliotecas que precisamos est\u00e3o dispon\u00edveis no pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual, mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Se voc\u00ea usar as VMs do Insper ent\u00e3o n\u00e3o precisa fazer nada. Todas as ferramentas j\u00e1 est\u00e3o instaladas l\u00e1 e a VM j\u00e1 vem pronta para uso. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -arch=sm_70 -std=c++14 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Compila\u00e7\u00e3o para CPU \u00b6 Se voc\u00ea ainda n\u00e3o tem uma GPU pode usar o suporte da thrust para OpenMP nas nossas primeiras aulas. Todos os trabalhos ser\u00e3o corrigidos usando GPU usando nvcc . Esta alternativa \u00e9 importante somente para as primeiras aulas, em que nem todos ter\u00e3o acesso ainda a uma GPU. Usaremos isso somente para facilitar o primeiro contato, mas essa op\u00e7\u00e3o n\u00e3o \u00e9 v\u00e1lida para avalia\u00e7\u00f5es. baixar o c\u00f3digo fonte da thrust no github . adicionar as seguintes flags no g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP : diz que a paraleliza\u00e7\u00e3o de device_vetor ser\u00e1 usando OpenMP -I/home/.... : o caminho passado ser\u00e1 usado na busca por include s. Coloque o caminho do reposit\u00f3rio da thrust -fopenmp : j\u00e1 conhecemos este ;) -x c++ : for\u00e7a a compila\u00e7\u00e3o de arquivos .cu como c\u00f3digo fonte C++ Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP -I/caminho/para/thrust/ -fopenmp -x c++ exemplo1-criacao-iteracao.cu -o exemplo1-cpu Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1-cpu que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Nem tudo o que roda usando thrust/OpenMP roda em GPU. Por essa raz\u00e3o, esse recurso ser\u00e1 usado somente para testes e nunca para avalia\u00e7\u00e3o. Transfer\u00eancia de dados \u00b6 Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Question Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ). Opera\u00e7\u00f5es de redu\u00e7\u00e3o \u00b6 Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust . Transforma\u00e7\u00f5es ponto a ponto \u00b6 Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor.","title":"17 - Introdu\u00e7\u00e3o a GPU"},{"location":"aulas/14-intro-gpu/#17-introducao-a-gpu","text":"Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas.","title":"17 - Introdu\u00e7\u00e3o a GPU"},{"location":"aulas/14-intro-gpu/#compilacao-para-gpu","text":"Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. O nvcc e todas as bibliotecas que precisamos est\u00e3o dispon\u00edveis no pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual, mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Se voc\u00ea usar as VMs do Insper ent\u00e3o n\u00e3o precisa fazer nada. Todas as ferramentas j\u00e1 est\u00e3o instaladas l\u00e1 e a VM j\u00e1 vem pronta para uso. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -arch=sm_70 -std=c++14 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35","title":"Compila\u00e7\u00e3o para GPU"},{"location":"aulas/14-intro-gpu/#compilacao-para-cpu","text":"Se voc\u00ea ainda n\u00e3o tem uma GPU pode usar o suporte da thrust para OpenMP nas nossas primeiras aulas. Todos os trabalhos ser\u00e3o corrigidos usando GPU usando nvcc . Esta alternativa \u00e9 importante somente para as primeiras aulas, em que nem todos ter\u00e3o acesso ainda a uma GPU. Usaremos isso somente para facilitar o primeiro contato, mas essa op\u00e7\u00e3o n\u00e3o \u00e9 v\u00e1lida para avalia\u00e7\u00f5es. baixar o c\u00f3digo fonte da thrust no github . adicionar as seguintes flags no g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP : diz que a paraleliza\u00e7\u00e3o de device_vetor ser\u00e1 usando OpenMP -I/home/.... : o caminho passado ser\u00e1 usado na busca por include s. Coloque o caminho do reposit\u00f3rio da thrust -fopenmp : j\u00e1 conhecemos este ;) -x c++ : for\u00e7a a compila\u00e7\u00e3o de arquivos .cu como c\u00f3digo fonte C++ Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP -I/caminho/para/thrust/ -fopenmp -x c++ exemplo1-criacao-iteracao.cu -o exemplo1-cpu Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1-cpu que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Nem tudo o que roda usando thrust/OpenMP roda em GPU. Por essa raz\u00e3o, esse recurso ser\u00e1 usado somente para testes e nunca para avalia\u00e7\u00e3o.","title":"Compila\u00e7\u00e3o para CPU"},{"location":"aulas/14-intro-gpu/#transferencia-de-dados","text":"Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Question Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ).","title":"Transfer\u00eancia de dados"},{"location":"aulas/14-intro-gpu/#operacoes-de-reducao","text":"Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust .","title":"Opera\u00e7\u00f5es de redu\u00e7\u00e3o"},{"location":"aulas/14-intro-gpu/#transformacoes-ponto-a-ponto","text":"Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor.","title":"Transforma\u00e7\u00f5es ponto a ponto"},{"location":"aulas/15-gpu-iteradores/","text":"18 - Iteradores em Thrust \u00b6 Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados. Warning Nesta aula trabalharemos extensivamente com a API da thrust e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio. Iteradores \u00b6 Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario . Opera\u00e7\u00f5es customiz\u00e1veis \u00b6 Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a thrust j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Question A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Warning A fun\u00e7\u00e3o count_if est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o ( link da issue ). N\u00e3o se esque\u00e7a de colocar const no par\u00e2metro de operator() . Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Question A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Details replace_if Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . \u00df Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"18 - Iteradores em Thrust"},{"location":"aulas/15-gpu-iteradores/#18-iteradores-em-thrust","text":"Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados. Warning Nesta aula trabalharemos extensivamente com a API da thrust e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio.","title":"18 - Iteradores em Thrust"},{"location":"aulas/15-gpu-iteradores/#iteradores","text":"Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario .","title":"Iteradores"},{"location":"aulas/15-gpu-iteradores/#operacoes-customizaveis","text":"Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a thrust j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Question A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Warning A fun\u00e7\u00e3o count_if est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o ( link da issue ). N\u00e3o se esque\u00e7a de colocar const no par\u00e2metro de operator() . Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Question A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Details replace_if Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . \u00df Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"Opera\u00e7\u00f5es customiz\u00e1veis"},{"location":"aulas/16-gpu-customizacao/","text":"Thrust - Opera\u00e7\u00f5es customizadas \u00b6 Vamos conhecer como criar opera\u00e7\u00f5es customizadas com Thrust. Para isso, vamos resolver um problema cl\u00e1ssico denominado Saxpy , o que significa Single precision A X plus Y . Na pr\u00e1tica, consiste em calcular um valor z , que \u00e9 dado por ax + y , onde a \u00e9 uma constante e x e y s\u00e3o vetores. O c\u00f3digo-fonte abaixo resolve o Saxpy em C++/Thrust. Vamos avali\u00e1-lo. #include <thrust/host_vector.h> #include <thrust/device_vector.h> #include <thrust/generate.h> #include <thrust/functional.h> #include <thrust/copy.h> #include <cstdlib> #include <algorithm> #include <iostream> #include <iomanip> using namespace std ; struct saxpy { int a ; saxpy ( int a_ ) : a ( a_ ) {}; __host__ __device__ double operator ()( const int & x , const int & y ) { return a * x + y ; } }; int main ( int argc , char * argv []) { if ( argc != 3 ) { cerr << \"***Numero incorreto de argumentos *** \\n \" ; return 1 ; } int n = atoi ( argv [ 1 ]); int m = atoi ( argv [ 2 ]); //gerar numeros aleatorios thrust :: host_vector < int > a ( n ); thrust :: host_vector < int > b ( n ); thrust :: host_vector < int > c ( n ); thrust :: generate ( a . begin (), a . end (), rand ); thrust :: generate ( b . begin (), b . end (), rand ); //transferimos para a GPU thrust :: device_vector < int > d_a = a ; thrust :: device_vector < int > d_b = b ; //transformacao thrust :: transform ( d_a . begin (), d_a . end (), d_b . begin (), d_b . end (), saxpy ( m )); thrust :: copy ( d_b . begin (), d_b . end (), c . begin ()); for ( int i = 0 ; i < n ; i ++ ) cout << setw ( 6 ) << c [ i ] << \" = \" << setw ( 2 ) << m << \"*\" << setw ( 5 ) << a [ i ] << \"+\" << setw ( 5 ) << b [ i ] << endl ; } Opera\u00e7\u00f5es customizadas em transform \u00b6 Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe: struct custom_transform { // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) // e GPU (device) // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU __host__ __device__ double operator ()( const double & x , const double & y ) { // isto pode ser usado com um transform que usa dois vetores // e coloca o resultado em um terceiro. // x \u00e9 um elemento do primeiro vetor // y \u00e9 o elemento correspondente do segundo vetor // o valor retornado \u00e9 colocado no vetor de resultados // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento. } }; A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo: thrust :: device_vector < double > A , B , C ; thrust :: transform ( A . begin (), A . end (), B . begin (), C . begin (), custom_transform ()); Note que os tipos dos vetores devem bater com os tipos declarados no struct . Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; O valor attr estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es. Calculando a norma / magnitude de um vetor \u00b6 A magnitude de um vetor consiste na raiz quadrada da soma do quadrado de seus elementos. Dessa forma, voc\u00ea deve complementar o c\u00f3digo abaixo, de modo a criar uma transforma\u00e7\u00e3o customizada square , a qual faz uma transforma\u00e7\u00e3o no vetor transformando os seus elementos ao quadrado, e posteriormente voc\u00ea deve fazer uma redu\u00e7\u00e3o, de modo a obter a magnitude do vetor. #include <iostream> #include <iomanip> #include <cstdlib> #include <chrono> #include <cstdlib> #include <algorithm> //INSIRA AS IMPORTACOES NECESSARIAS DA THRUST #include <cmath> #include <random> using namespace std :: chrono ; void reportTime ( const char * msg , steady_clock :: duration span ) { auto ms = duration_cast < milliseconds > ( span ); std :: cout << msg << \" - levou - \" << ms . count () << \" milisegundos\" << std :: endl ; } // CRIE UMA FUNCTOR PARA CALCULAR A SQUARE // IMPLEMENTE O CALCULO DA MAGNITUDE COM THRUST float magnitude ( ) { float result ; // ... add Thrust calls // AQUI VAO AS CHAMADAS THRUST return result ; } int main ( int argc , char ** argv ) { if ( argc != 2 ) { std :: cerr << argv [ 0 ] << \": numero invalido de argumentos \\n \" ; std :: cerr << \"uso: \" << argv [ 0 ] << \" tamanho do vetor \\n \" ; return 1 ; } int n = std :: atoi ( argv [ 1 ]); //numero de elementos steady_clock :: time_point ts , te ; // Fa\u00e7a um vector em thrust // inicilize o vector ts = steady_clock :: now (); std :: generate ( , , std :: rand ); te = steady_clock :: now (); reportTime ( \"Inicializacao\" , te - ts ); // Calcule a magnitude do vetor ts = steady_clock :: now (); float len = magnitude ( v_d ); te = steady_clock :: now (); reportTime ( \"Tempo para calculo\" , te - ts ); std :: cout << std :: fixed << std :: setprecision ( 4 ); std :: cout << \"Magnitude : \" << len << std :: endl ; } Fusion \u00b6 H\u00e1 opera\u00e7\u00f5es de transforma\u00e7\u00e3o e redu\u00e7\u00e3o feitas anteriormente que realizam muita troca de dados. Seria poss\u00edvel otimizar isso? A resposta \u00e9 sim. A Thrust possui o conceito de fusion kernel , o que representa uma estrat\u00e9gia para otimizar transforma\u00e7\u00f5es e redu\u00e7\u00f5es. Modifique o c\u00f3digo anteriormente desenvolvido, agora fazendo uso da transforma\u00e7\u00e3o abaixo: std :: sqrt ( thrust :: transform_reduce ( v . begin (), v . end (), unary_op , init , binary_op )); Pergunta: para o problema da magnitude, quem \u00e9 a unary_op e a binary_op ? Qual o valor de init ?","title":"Thrust - Opera\u00e7\u00f5es customizadas"},{"location":"aulas/16-gpu-customizacao/#thrust-operacoes-customizadas","text":"Vamos conhecer como criar opera\u00e7\u00f5es customizadas com Thrust. Para isso, vamos resolver um problema cl\u00e1ssico denominado Saxpy , o que significa Single precision A X plus Y . Na pr\u00e1tica, consiste em calcular um valor z , que \u00e9 dado por ax + y , onde a \u00e9 uma constante e x e y s\u00e3o vetores. O c\u00f3digo-fonte abaixo resolve o Saxpy em C++/Thrust. Vamos avali\u00e1-lo. #include <thrust/host_vector.h> #include <thrust/device_vector.h> #include <thrust/generate.h> #include <thrust/functional.h> #include <thrust/copy.h> #include <cstdlib> #include <algorithm> #include <iostream> #include <iomanip> using namespace std ; struct saxpy { int a ; saxpy ( int a_ ) : a ( a_ ) {}; __host__ __device__ double operator ()( const int & x , const int & y ) { return a * x + y ; } }; int main ( int argc , char * argv []) { if ( argc != 3 ) { cerr << \"***Numero incorreto de argumentos *** \\n \" ; return 1 ; } int n = atoi ( argv [ 1 ]); int m = atoi ( argv [ 2 ]); //gerar numeros aleatorios thrust :: host_vector < int > a ( n ); thrust :: host_vector < int > b ( n ); thrust :: host_vector < int > c ( n ); thrust :: generate ( a . begin (), a . end (), rand ); thrust :: generate ( b . begin (), b . end (), rand ); //transferimos para a GPU thrust :: device_vector < int > d_a = a ; thrust :: device_vector < int > d_b = b ; //transformacao thrust :: transform ( d_a . begin (), d_a . end (), d_b . begin (), d_b . end (), saxpy ( m )); thrust :: copy ( d_b . begin (), d_b . end (), c . begin ()); for ( int i = 0 ; i < n ; i ++ ) cout << setw ( 6 ) << c [ i ] << \" = \" << setw ( 2 ) << m << \"*\" << setw ( 5 ) << a [ i ] << \"+\" << setw ( 5 ) << b [ i ] << endl ; }","title":"Thrust - Opera\u00e7\u00f5es customizadas"},{"location":"aulas/16-gpu-customizacao/#operacoes-customizadas-em-transform","text":"Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe: struct custom_transform { // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) // e GPU (device) // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU __host__ __device__ double operator ()( const double & x , const double & y ) { // isto pode ser usado com um transform que usa dois vetores // e coloca o resultado em um terceiro. // x \u00e9 um elemento do primeiro vetor // y \u00e9 o elemento correspondente do segundo vetor // o valor retornado \u00e9 colocado no vetor de resultados // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento. } }; A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo: thrust :: device_vector < double > A , B , C ; thrust :: transform ( A . begin (), A . end (), B . begin (), C . begin (), custom_transform ()); Note que os tipos dos vetores devem bater com os tipos declarados no struct . Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; O valor attr estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es.","title":"Opera\u00e7\u00f5es customizadas em transform"},{"location":"aulas/16-gpu-customizacao/#calculando-a-norma-magnitude-de-um-vetor","text":"A magnitude de um vetor consiste na raiz quadrada da soma do quadrado de seus elementos. Dessa forma, voc\u00ea deve complementar o c\u00f3digo abaixo, de modo a criar uma transforma\u00e7\u00e3o customizada square , a qual faz uma transforma\u00e7\u00e3o no vetor transformando os seus elementos ao quadrado, e posteriormente voc\u00ea deve fazer uma redu\u00e7\u00e3o, de modo a obter a magnitude do vetor. #include <iostream> #include <iomanip> #include <cstdlib> #include <chrono> #include <cstdlib> #include <algorithm> //INSIRA AS IMPORTACOES NECESSARIAS DA THRUST #include <cmath> #include <random> using namespace std :: chrono ; void reportTime ( const char * msg , steady_clock :: duration span ) { auto ms = duration_cast < milliseconds > ( span ); std :: cout << msg << \" - levou - \" << ms . count () << \" milisegundos\" << std :: endl ; } // CRIE UMA FUNCTOR PARA CALCULAR A SQUARE // IMPLEMENTE O CALCULO DA MAGNITUDE COM THRUST float magnitude ( ) { float result ; // ... add Thrust calls // AQUI VAO AS CHAMADAS THRUST return result ; } int main ( int argc , char ** argv ) { if ( argc != 2 ) { std :: cerr << argv [ 0 ] << \": numero invalido de argumentos \\n \" ; std :: cerr << \"uso: \" << argv [ 0 ] << \" tamanho do vetor \\n \" ; return 1 ; } int n = std :: atoi ( argv [ 1 ]); //numero de elementos steady_clock :: time_point ts , te ; // Fa\u00e7a um vector em thrust // inicilize o vector ts = steady_clock :: now (); std :: generate ( , , std :: rand ); te = steady_clock :: now (); reportTime ( \"Inicializacao\" , te - ts ); // Calcule a magnitude do vetor ts = steady_clock :: now (); float len = magnitude ( v_d ); te = steady_clock :: now (); reportTime ( \"Tempo para calculo\" , te - ts ); std :: cout << std :: fixed << std :: setprecision ( 4 ); std :: cout << \"Magnitude : \" << len << std :: endl ; }","title":"Calculando a norma / magnitude de um vetor"},{"location":"aulas/16-gpu-customizacao/#fusion","text":"H\u00e1 opera\u00e7\u00f5es de transforma\u00e7\u00e3o e redu\u00e7\u00e3o feitas anteriormente que realizam muita troca de dados. Seria poss\u00edvel otimizar isso? A resposta \u00e9 sim. A Thrust possui o conceito de fusion kernel , o que representa uma estrat\u00e9gia para otimizar transforma\u00e7\u00f5es e redu\u00e7\u00f5es. Modifique o c\u00f3digo anteriormente desenvolvido, agora fazendo uso da transforma\u00e7\u00e3o abaixo: std :: sqrt ( thrust :: transform_reduce ( v . begin (), v . end (), unary_op , init , binary_op )); Pergunta: para o problema da magnitude, quem \u00e9 a unary_op e a binary_op ? Qual o valor de init ?","title":"Fusion"},{"location":"aulas/17-gpu-aleatoriedade/","text":"17 - GPU e n\u00fameros aleat\u00f3rios \u00b6 Revis\u00e3o de n\u00fameros aleat\u00f3rios \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). A thrust cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++. Question Consulte a documenta\u00e7\u00e3o oficial da thrust e encontre as p\u00e1ginas que descrevem os engines e distributions implementados. Resposta Abaixo temos um trecho de um c\u00f3digo-fonte que nos mostra como gerar n\u00fameros aleat\u00f3rios com thrust. #include <thrust/random.h> #include <thrust/device_vector.h> #include <thrust/transform.h> #include <thrust/iterator/counting_iterator.h> #include <vector> int main() { thrust::default_random_engine eng(10); thrust::uniform_real_distribution<double> d(20, 30); for (int i = 0; i < 10; i++) { std::cout << d(eng) << \"\\n\"; } } Vamos agora fazer um uso b\u00e1sico dessas fun\u00e7\u00f5es. Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] . Seu programa dever\u00e1 estar implementado usando os tipos definidos em thrust::random . Um ponto importante da API thrust para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Nosso pr\u00f3ximo exerc\u00edcio trata justamente deste uso. Example Fa\u00e7a um programa que cria um vetor com 10 elementos e aplica uma opera\u00e7\u00e3o customizada que seta cada elemento com um valor aleat\u00f3rio. Use as mesmas configura\u00e7\u00f5es do exerc\u00edcio anterior. Resposta Use o trecho de c\u00f3digo disponibilizado neste gist para ver a estrutura da sua fun\u00e7\u00e3o customizada e como voc\u00ea pode criar uma transforma\u00e7\u00e3o que a invoca para cada elemento de um vetor. Warning Voc\u00ea pode prosseguir mesmo se seu vetor tem 10 n\u00fameros iguais. Gerando n\u00fameros pseudo-aleat\u00f3rios em GPU \u00b6 Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho! Question Que abordagem voc\u00ea usou para gerar n\u00fameros aleat\u00f3rios em paralelo com OpenMP? Resposta Se voc\u00ea realizou todas as tarefas, deve ter criado um gerador de n\u00fameros pseudo-aleat\u00f3rios para cada thread para calcular o valor de \\pi \\pi usando Monte Carlo. Question Voc\u00ea acha que poder\u00edamos aplicar a mesma abordagem para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em GPU? Por qu\u00ea? Resposta Sem cuidados adicionais, n\u00e3o obter\u00edamos bons resultados. A abordagem usada na aula de openMP pressup\u00f5e um n\u00famero relativamente pequeno de threads, de forma que a sequ\u00eancia criada por cada gerador \u00e9 menor, por\u00e9m grande o suficiente para ter qualidade. No caso de usarmos uma GPU, o n\u00famero de threads pode ser muito grande, de forma que cada gerador geraria sequ\u00eancias muito curtas, e por isso perder\u00edamos em qualidade da sequ\u00eancia. Seeds em programas massivamente paralelos \u00b6 Em computa\u00e7\u00e3o massivamente paralela, em geral, existem duas abordagens. Abordagem 1 : usar seeds diferentes em cada thread. Abordagem 2 : usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed. Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads. Example Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar a estrat\u00e9gia de acesso direto aos dados (como foi feito no exerc\u00edcio da imagem) e usar o \u00edndice recebido como seed . Lembre-se que a seed \u00e9 definida ao criar o default_random_engine . No exemplo abaixo, voc\u00ea pode ver que ela \u00e9 definida com o valor 10 . thrust :: default_random_engine eng ( 10 ); Voc\u00ea deve ter percebido que todos os n\u00fameros gerados s\u00e3o parecidos, mas n\u00e3o id\u00eanticos. Isso ocorre pois geradores com *seed*s pr\u00f3ximos geram sequ\u00eancias que s\u00e3o inicialmente parecidas (e depois diferem). Podemos consertar isto usando seeds mais distantes. Example Multiplique i por um valor grande e tente de novo. Verifique que agora os n\u00fameros s\u00e3o diferentes Exerc\u00edcio pr\u00e1tico \u00b6 Vamos trabalhar com um m\u00e9todo probabil\u00edstico de estima\u00e7\u00e3o do pi neste \u00faltimo exerc\u00edcio. O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Resgate a implementa\u00e7\u00e3o sequencial deste algoritmo realizada na aula (dispon\u00edvel neste gist ) e rode-a para N=100000000 Example Paralelize o c\u00f3digo acima em GPU. Use ambas as abordagens acima em programas distintos para lidar com os geradores de n\u00fameros aleat\u00f3rios.","title":"17 - GPU e n\u00fameros aleat\u00f3rios"},{"location":"aulas/17-gpu-aleatoriedade/#17-gpu-e-numeros-aleatorios","text":"","title":"17 - GPU e n\u00fameros aleat\u00f3rios"},{"location":"aulas/17-gpu-aleatoriedade/#revisao-de-numeros-aleatorios","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). A thrust cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++. Question Consulte a documenta\u00e7\u00e3o oficial da thrust e encontre as p\u00e1ginas que descrevem os engines e distributions implementados. Resposta Abaixo temos um trecho de um c\u00f3digo-fonte que nos mostra como gerar n\u00fameros aleat\u00f3rios com thrust. #include <thrust/random.h> #include <thrust/device_vector.h> #include <thrust/transform.h> #include <thrust/iterator/counting_iterator.h> #include <vector> int main() { thrust::default_random_engine eng(10); thrust::uniform_real_distribution<double> d(20, 30); for (int i = 0; i < 10; i++) { std::cout << d(eng) << \"\\n\"; } } Vamos agora fazer um uso b\u00e1sico dessas fun\u00e7\u00f5es. Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] . Seu programa dever\u00e1 estar implementado usando os tipos definidos em thrust::random . Um ponto importante da API thrust para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Nosso pr\u00f3ximo exerc\u00edcio trata justamente deste uso. Example Fa\u00e7a um programa que cria um vetor com 10 elementos e aplica uma opera\u00e7\u00e3o customizada que seta cada elemento com um valor aleat\u00f3rio. Use as mesmas configura\u00e7\u00f5es do exerc\u00edcio anterior. Resposta Use o trecho de c\u00f3digo disponibilizado neste gist para ver a estrutura da sua fun\u00e7\u00e3o customizada e como voc\u00ea pode criar uma transforma\u00e7\u00e3o que a invoca para cada elemento de um vetor. Warning Voc\u00ea pode prosseguir mesmo se seu vetor tem 10 n\u00fameros iguais.","title":"Revis\u00e3o de n\u00fameros aleat\u00f3rios"},{"location":"aulas/17-gpu-aleatoriedade/#gerando-numeros-pseudo-aleatorios-em-gpu","text":"Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho! Question Que abordagem voc\u00ea usou para gerar n\u00fameros aleat\u00f3rios em paralelo com OpenMP? Resposta Se voc\u00ea realizou todas as tarefas, deve ter criado um gerador de n\u00fameros pseudo-aleat\u00f3rios para cada thread para calcular o valor de \\pi \\pi usando Monte Carlo. Question Voc\u00ea acha que poder\u00edamos aplicar a mesma abordagem para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em GPU? Por qu\u00ea? Resposta Sem cuidados adicionais, n\u00e3o obter\u00edamos bons resultados. A abordagem usada na aula de openMP pressup\u00f5e um n\u00famero relativamente pequeno de threads, de forma que a sequ\u00eancia criada por cada gerador \u00e9 menor, por\u00e9m grande o suficiente para ter qualidade. No caso de usarmos uma GPU, o n\u00famero de threads pode ser muito grande, de forma que cada gerador geraria sequ\u00eancias muito curtas, e por isso perder\u00edamos em qualidade da sequ\u00eancia.","title":"Gerando n\u00fameros pseudo-aleat\u00f3rios em GPU"},{"location":"aulas/17-gpu-aleatoriedade/#seeds-em-programas-massivamente-paralelos","text":"Em computa\u00e7\u00e3o massivamente paralela, em geral, existem duas abordagens. Abordagem 1 : usar seeds diferentes em cada thread. Abordagem 2 : usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed. Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads. Example Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar a estrat\u00e9gia de acesso direto aos dados (como foi feito no exerc\u00edcio da imagem) e usar o \u00edndice recebido como seed . Lembre-se que a seed \u00e9 definida ao criar o default_random_engine . No exemplo abaixo, voc\u00ea pode ver que ela \u00e9 definida com o valor 10 . thrust :: default_random_engine eng ( 10 ); Voc\u00ea deve ter percebido que todos os n\u00fameros gerados s\u00e3o parecidos, mas n\u00e3o id\u00eanticos. Isso ocorre pois geradores com *seed*s pr\u00f3ximos geram sequ\u00eancias que s\u00e3o inicialmente parecidas (e depois diferem). Podemos consertar isto usando seeds mais distantes. Example Multiplique i por um valor grande e tente de novo. Verifique que agora os n\u00fameros s\u00e3o diferentes","title":"Seeds em programas massivamente paralelos"},{"location":"aulas/17-gpu-aleatoriedade/#exercicio-pratico","text":"Vamos trabalhar com um m\u00e9todo probabil\u00edstico de estima\u00e7\u00e3o do pi neste \u00faltimo exerc\u00edcio. O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Resgate a implementa\u00e7\u00e3o sequencial deste algoritmo realizada na aula (dispon\u00edvel neste gist ) e rode-a para N=100000000 Example Paralelize o c\u00f3digo acima em GPU. Use ambas as abordagens acima em programas distintos para lidar com os geradores de n\u00fameros aleat\u00f3rios.","title":"Exerc\u00edcio pr\u00e1tico"},{"location":"projetos/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A Estrat\u00e9gias a serem estudadas \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/#estrategias-a-serem-estudadas","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas"},{"location":"projetos/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/heuristico/","text":"Heur\u00edstica de Alinhamento Local de Smith-Waterman \u00b6 Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/heuristico/#heuristica-de-alinhamento-local-de-smith-waterman","text":"Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/local/","text":"Um algoritmo Local para Alinhamento \u00b6 Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. Em problemas de alinhamento, varreduras suportadas por aleatoriedade tem produzido algoritmos bastante efetivos. Dentro deste contexto, vamos considerar o algoritmo proposto abaixo: ALGORITMO BUSCA LOCAL COM ALEATORIEDADE Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Pesos wmat, wmis e wgap para match, mismatch e gap respectivamente Sa\u00edda: Score de um alinhamento das sequencias Subsequencias alinhadas 1. Gerar uma subsequencia sb=b[j,j+1,...,j+k] de b, de tamanho aleat\u00f3rio k, 1 < =k < =m 2. Gerar um n\u00famero aleat\u00f3rio inteiro positivo p 3. Gerar p subsequencias sa=a[i,i+1,...,i+k] de a, com tamanho k calculado no passo (1) 4. Calcular os scores de cada par (sa,sb) com os pesos wmat, wmis e wgap 5. Devolver o score m\u00e1ximo m entre os scores do passo (4) e as subsequencias associadas a ele A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele. Testar o algoritmo diversas vezes e comparar seus resultados com a heur\u00edstica do primeiro projeto observando, principalmente, o seu comportamento em rela\u00e7\u00e3o aos valores aleat\u00f3rios k e p. Estes resultados e sua compara\u00e7\u00e3o dever\u00e3o estar presentes no relat\u00f3rio a ser entregue posteriormente. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.","title":"Um algoritmo Local para Alinhamento"},{"location":"projetos/local/#um-algoritmo-local-para-alinhamento","text":"Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. Em problemas de alinhamento, varreduras suportadas por aleatoriedade tem produzido algoritmos bastante efetivos. Dentro deste contexto, vamos considerar o algoritmo proposto abaixo: ALGORITMO BUSCA LOCAL COM ALEATORIEDADE Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Pesos wmat, wmis e wgap para match, mismatch e gap respectivamente Sa\u00edda: Score de um alinhamento das sequencias Subsequencias alinhadas 1. Gerar uma subsequencia sb=b[j,j+1,...,j+k] de b, de tamanho aleat\u00f3rio k, 1 < =k < =m 2. Gerar um n\u00famero aleat\u00f3rio inteiro positivo p 3. Gerar p subsequencias sa=a[i,i+1,...,i+k] de a, com tamanho k calculado no passo (1) 4. Calcular os scores de cada par (sa,sb) com os pesos wmat, wmis e wgap 5. Devolver o score m\u00e1ximo m entre os scores do passo (4) e as subsequencias associadas a ele A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele. Testar o algoritmo diversas vezes e comparar seus resultados com a heur\u00edstica do primeiro projeto observando, principalmente, o seu comportamento em rela\u00e7\u00e3o aos valores aleat\u00f3rios k e p. Estes resultados e sua compara\u00e7\u00e3o dever\u00e3o estar presentes no relat\u00f3rio a ser entregue posteriormente. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.","title":"Um algoritmo Local para Alinhamento"},{"location":"projetos/2021-2/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2021-2/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. import random n = 10 # tamanho da primeira sequ\u00eancia m = 40 # tamanho da segunda sequ\u00eancia file = 'dna.seq' # nome do arquivo a ser gerado f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) Um poss\u00edvel output para este c\u00f3digo acima \u00e9: 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2021-2/#estrategias-a-serem-estudadas-e-correcao-automatica","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/2021-2/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/2021-2/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/2021-2/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/2021-2/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/2021-2/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/2021-2/busca-exaustiva/","text":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound \u00b6 Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/2021-2/busca-exaustiva/#solucao-busca-exaustiva-branch-and-bound","text":"Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/2021-2/busca-local/","text":"Solu\u00e7\u00e3o Busca local \u00b6 A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/2021-2/busca-local/#solucao-busca-local","text":"A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/2021-2/heuristico/","text":"Solu\u00e7\u00e3o heur\u00edstica \u00b6 Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos . Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250). Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa verify ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/2021-2/heuristico/#solucao-heuristica","text":"Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos . Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250). Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa verify ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. Para a entrega, usaremos o site codePost , voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/2021-2/paralelismo-gpu/","text":"Paralelismo em GPU \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 . Para a entrega, usaremos o site codePost . \u2192","title":"Paralelismo em GPU"},{"location":"projetos/2021-2/paralelismo-gpu/#paralelismo-em-gpu","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local.","title":"Paralelismo em GPU"},{"location":"projetos/2021-2/paralelismo-gpu/#compilacao-do-programa","text":"Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 . Para a entrega, usaremos o site codePost . \u2192","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/2021-2/paralelismo-multicore/","text":"Paralelismo multi-core \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Para a entrega, usaremos o site codePost .","title":"Paralelismo multi-core"},{"location":"projetos/2021-2/paralelismo-multicore/#paralelismo-multi-core","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.","title":"Paralelismo multi-core"},{"location":"projetos/2021-2/paralelismo-multicore/#compilacao-do-programa","text":"Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Para a entrega, usaremos o site codePost .","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/2021-2/relatorio-1/","text":"Relat\u00f3rio - v1 \u00b6 Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . Data de entrega: 31/10/2021, pelo blackboard.","title":"Relat\u00f3rio - v1"},{"location":"projetos/2021-2/relatorio-1/#relatorio-v1","text":"Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . Data de entrega: 31/10/2021, pelo blackboard.","title":"Relat\u00f3rio - v1"},{"location":"projetos/2022-1/","text":"Alinhamento de Sequencias de DNA \u00b6 Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes. Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06) Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2022-1/#alinhamento-de-sequencias-de-dna","text":"Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es. O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch) . Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade: Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch) . Assim, teremos o seguinte n\u00edvel de similaridade: 23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7 Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma: Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, encontrar o alinhamento que maximize o n\u00edvel de similaridade. Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m , onde n \u00e9 o tamanho da primeira sequencia e, m , o tamanho da segunda. Assuma n \u2264 200 e m \u2264 200 . A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda. 5 7 AT-CC TTTCCAA A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade. 2 Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.","title":"Alinhamento de Sequencias de DNA"},{"location":"projetos/2022-1/#estrategias-a-serem-estudadas-e-correcao-automatica","text":"Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (18/03) Busca Local (01/04) Busca Exaustiva (15/04) Relat\u00f3rio Preliminar (29/04) Paralelismo Multicore (13/05) Paralelismo GPU (27/05) Relat\u00f3rio Final (03/06)","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/2022-1/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/2022-1/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/2022-1/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/2022-1/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/2022-1/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/2022-1/SequenceGenerator/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); GERADOR DE INST\u00c2NCIAS PARA COMPARA\u00c7\u00c3O DE SEQUENCIAS DE DNA Para usar este gerador, voc\u00ea deve fornecer tr\u00eas par\u00e2metros: n = tamanho da primeira sequencia m = tamanho da segunda inst\u00e2ncia file = nome do arquivo da inst\u00e2ncia a ser gerada import random n = 10 m = 40 file = 'dna.seq' f = open ( file , 'w' ) seq = [ str ( n ) + ' \\n ' , str ( m ) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = n )) + ' \\n ' , '' . join ( random . choices ([ 'A' , 'T' , 'C' , 'G' , '-' ], k = m ))] f . writelines ( seq ) f . close () print ( '' . join ( seq )) 10 40 TGGCGAT--C AGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A","title":"SequenceGenerator"},{"location":"projetos/2022-1/heuristico/","text":"Heur\u00edstica de Alinhamento Local de Smith-Waterman \u00b6 Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"},{"location":"projetos/2022-1/heuristico/#heuristica-de-alinhamento-local-de-smith-waterman","text":"Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser: Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores Escolha uma que produza o score m\u00e1ximo Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA. Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia: ALGORITMO SMITH-WATERMAN Entrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente Sa\u00edda: score m\u00e1ximo de alinhamento 1. Inicializar H[i,0]=0, 0\u2264i\u2264n 2. Inicializar H[0,j]=0, 0\u2264j\u2264m 3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m: 4. Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, w(a[i],b[j])= -1 se houve mismatch e w(a[i],b[j])= -1 se houve gap 5. Calcular dele\u00e7\u00e3o = H[i-1,j] - 1 6. Calcular inser\u00e7\u00e3o = H[i,j-1] - 1 7. Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o) 9. Retornar o m\u00e1ximo de H[_,_] Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos: http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA: Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0). No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0), Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado. Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap): Sequ\u00eancia 1 = A-CACACTA Sequ\u00eancia 2 = AGCACAC-A A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas: Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct. a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias. No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf .","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman"}]}